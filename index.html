<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>ЧЁРНАЯ СТРЕЛА</title>

<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">

<style>
/* Montserrat body font */
body{ font-family:"Montserrat", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
h1{ font-family:"Bebas Neue Pro", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

html, body { -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
img{ -webkit-user-drag:none; }

:root {
  /* единая адаптивная переменная для расстояния между кнопками */
  --controls-gap: clamp(18px, 3vw, 28px);

  /* optional vertical spacing between sections */
  --player-gap: 12px;
}

.controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--controls-gap) !important; /* фиксируем окончательно */
}

.btn {
  display: grid;
  place-items: center;
  width: var(--btn-size);
  height: var(--btn-size);
  background: transparent;
  border: 0;
  padding: 0;
}

.btn svg {
  width: 100%;
  height: 100%;
  display: block;
}

/* UX: remove orange highlight/outline on tap/focus for interactive elements */
html, body { -webkit-tap-highlight-color: transparent; }
:where(a, button, [tabindex]) { outline: none; }
:where(a, button, [tabindex]):focus,
:where(a, button, [tabindex]):focus-visible { outline: none; box-shadow: none; }

/* Perf: hint composition to smooth transform animation of the sheet */
.sheet { will-change: transform; transform: translateZ(0); }
.overlay { transform: translateZ(0); }

  @font-face {
  font-family: "Bebas Neue Pro";
  src: url("./fonts/BebasNeuePro_Regular.woff2") format("woff2");
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Bebas Neue Pro";
  src: url("./fonts/BebasNeuePro_Bold.woff2") format("woff2");
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Bebas Neue Pro";
  src: url("./fonts/BebasNeuePro_Light.woff2") format("woff2");
  font-weight: 300;
  font-style: normal;
  font-display: swap;
}

  :root{
    --page-bg: #000;
    --content-max-w: 500px;
    --side-pad: 12px;

    --title-block-w: 100%;
    --title-top: 79px;
    --title-bottom: 100px;
    --title-size: 100px;
    --title-weight: 400;
    --title-color: #fff;
    --title-letter-spacing: .5px;
    --title-line-height: 0.86;

    --divider-thickness: 2px;
    --divider-color: #282828;
    --divider-top: 12px;
    --divider-bottom: 12px;

    --t-title-size: 13px;
    --t-title-weight: 650;
    --t-title-color: #DBDADA;

    --t-chapter-size: 12px;
    --t-chapter-weight: 650;
    --t-chapter-color: #828282;

    --t-time-size: 12px;
    --t-time-weight: 700;
    --t-time-color: #616161;

    --track-title-maxw: 295px;

    --aff-bg: rgba(43,43,43,.75);
    --aff-radius: 7px;
    --aff-border: 1px solid rgba(83, 83, 83, 0.2);
    --aff-text-size: 13px;
    --aff-text-weight: 750;
    --aff-text-color: #939393;
    --aff-pad-v: 14px;
    --aff-pad-h: 14px;
    --aff-blur: 4px;

    --player-bg: #000;
    --light-color: rgba(255,255,255,.55);
    --light-blur: 34px;
    --light-size: 64vw;

    --time-top-margin: 10px;
    --time-font-weight: 800;
    --time-font-size: 14px;
    --time-color: #e7e7e7;

    --btn-size: 56px;
  
  --divider-min: 320px;
  --divider-max: 500px;
  --viewport-w: 100vw;
  --content-inner-w: clamp(var(--divider-min), calc(var(--viewport-w) - 2 * var(--side-pad)), var(--divider-max));
  --divider-width: var(--content-inner-w);
  --aff-width: calc(var(--content-inner-w) + 4px);
}

/* === Centered container (FRAME) ========================================== */
.frame{
  --page-gutter: 0px;              /* внешние поля страницы при желании */
  --container-max: 500px;          /* лимит 500px */
  width: min(calc(100% - 2 * var(--page-gutter)), var(--container-max));
  margin-inline: auto;             /* центрируем по экрану */
  position: relative;

  /* Рельсы от ширины КОНТЕЙНЕРА .frame */
  --edge-pad: 8px;                 /* поля от краёв контейнера */
  --min: 0px;                      /* нижняя граница (можно 320px) */
  --cap: 9999px;                   /* верхняя граница (поставь 450px при необходимости) */
  --rail: clamp(var(--min), calc(100% - 2 * var(--edge-pad)), var(--cap));
  --divider-width: var(--rail);
  --aff-width: var(--rail);
}

  html,body{height:100%;}
  body{
    margin:0; background:var(--page-bg); color:#fff;
    font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    overflow-x:hidden;
  }

  #stars-canvas{ position:fixed; inset:0; z-index:0; display:block; }

  .page{ position:relative; z-index:1; min-height:100dvh; display:flex; }
  .content{
    width:100%; max-width:var(--content-max-w);
    margin:0 auto; padding:0 var(--side-pad) 72px;
    box-sizing:border-box;
  }

  .title-wrap{ width:var(--title-block-w); margin:var(--title-top) auto var(--title-bottom); text-align:center; }
  .title{
    margin:0;
    font-family:"Bebas Neue Pro";
    font-size:var(--title-size);
    font-weight:var(--title-weight);
    letter-spacing:var(--title-letter-spacing);
    line-height:var(--title-line-height);
    color:var(--title-color);
    text-transform:uppercase;
  }

  .tracks{ width:100%; }
  .divider{ width: var(--divider-width); height:var(--divider-thickness); background: var(--divider-color); margin: var(--divider-top) 0 var(--divider-bottom); display:block; margin-left: calc(50% - (var(--divider-width) / 2)); margin-right:0; }
  .track{ touch-action: pan-y;  position:relative; display:flex; align-items:center; justify-content:space-between; gap:12px; }
  .track-left{ min-width:0; }
  .track-title{ max-width:var(--track-title-maxw); font-size:var(--t-title-size); font-weight:var(--t-title-weight); color:var(--t-title-color); line-height:1.25; }
  .track-chapter{ margin-top:2px; font-size:var(--t-chapter-size); font-weight:var(--t-chapter-weight); color:var(--t-chapter-color); }
  .track-time{ margin-left:auto; flex:0 0 auto; font-size:var(--t-time-size); font-weight:var(--t-time-weight); color:var(--t-time-color); }

  .aff-card{ position:absolute; left:50%; top:50%; transform: translate(-50%,-50%); width: var(--aff-width); box-sizing: border-box; min-height: calc(var(--aff-pad-v)*2 + var(--aff-text-size)*1.2); padding:var(--aff-pad-v) var(--aff-pad-h); background:var(--aff-bg); border:var(--aff-border); border-radius:var(--aff-radius); text-align:center; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:2; backdrop-filter:blur(var(--aff-blur)); }
  .aff-text{ font-size:var(--aff-text-size); font-weight:var(--aff-text-weight); color:var(--aff-text-color); line-height:1.2; white-space:nowrap; opacity:0; transition: opacity .6s ease; }
  .aff-text.show{ opacity:1; }

  .player{ width:100%; max-width:var(--content-max-w); margin:36px auto 80px; padding:0 var(--side-pad); box-sizing:border-box; background:var(--player-bg); display:none; }
  :target.player{ display:block; }

  .player .header{ position:relative; width:100%; }
  .player .light{ position:absolute; left:50%; top:0; width:var(--light-size); height:var(--light-size); transform:translate(-50%,-42%); border-radius:50%; background:radial-gradient(circle, var(--light-color) 0%, rgba(0,0,0,0) 60%); filter:blur(var(--light-blur)); pointer-events:none; z-index:0; }
  .player .svg-player{ position:relative; z-index:1; width:100%; }

  .player h2{ margin:16px 0 4px; font-weight:900; font-size:18px; line-height:1.2; }
  .player .chapter{ margin:0 0 10px; font-weight:800; font-size:14px; opacity:.95; }

  .progress{ width:100%; height:6px; background:#262626; border-radius:999px; position:relative; overflow:hidden; }
  .progress__bar{ position:absolute; left:0; top:0; bottom:0; width:0%; background:#f2f2f2; border-radius:999px; }
  .time{ margin-top:var(--time-top-margin); display:flex; justify-content:space-between; font: var(--time-font-weight) var(--time-font-size)/1.1 system-ui; color:var(--time-color); }

/* === ADAPTIVE GAP (landscape default) === */
.controls {
  display: flex;
  align-items: center;
  justify-content: center;
  
  --controls-offset: 60px;
  position: relative;
  top: var(--controls-offset);
}

  .btn{ display:grid; place-items:center; width:var(--btn-size); height:var(--btn-size); background:transparent; border:0; padding:0; }
  .btn svg{ width:100%; height:100%; display:block; }

:root {
  --size-prev:    clamp(25px, 4vw, 32px);
  --size-back15:  clamp(30px, 4.5vw, 38px);
  --size-play:    clamp(50px, 6vw, 64px);
  --size-fwd30:   clamp(30px, 4.5vw, 38px);
  --size-next:    clamp(25px, 4vw, 32px);
}
#prev img   { width: var(--size-prev);   height: var(--size-prev); }
#back15 img { width: var(--size-back15); height: var(--size-back15); }
#pp img     { width: var(--size-play);   height: var(--size-play); }
#fwd30 img  { width: var(--size-fwd30);  height: var(--size-fwd30); }
#next img   { width: var(--size-next);   height: var(--size-next); }

/* === Player vertical layout & movable sections === */
.player{
  display: flex;
  flex-direction: column;
  align-items: center;              /* center column */
  gap: var(--player-gap);
}

/* Order top-to-bottom */
.player .header       { order:10; position:relative; top: calc(var(--axis) + var(--head-dy)); }
.player h2            { order:20; position:relative; top: calc(var(--axis) + var(--title-dy)); }
.player .controls     { order:30; position:relative; top: calc(var(--axis) + var(--controls-dy)); }
.player .chapter      { order:40; position:relative; top: calc(var(--axis) + var(--chapter-dy)); }
.player .progress     { order:50; position:relative; top: calc(var(--axis) + var(--progress-dy)); width:100%; }
.player .time         { order:60; position:relative; top: calc(var(--axis) + var(--progress-dy)); width:100%; }


          /* Disabled state for nav buttons */
          .btn[disabled],
          .btn[aria-disabled="true"],
          .btn.is-disabled { opacity:.35; filter: grayscale(1); pointer-events:none; cursor: default; }
    
</style>
<style>
/* === Main list titles: clamp width + CSS ellipsis (no JS) === */
:root { --card-title-w: clamp(220px, 40vw, 290px); }

.track-title{
  display: block;
  max-width: var(--card-title-w);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-weight: var(--t-title-weight, 650);
  font-size: var(--t-title-size, 13px);
  line-height: 1.25;
}

/* If titles sit inside flex containers, ensure they can shrink for ellipsis */
.track-title, .card-title-wrap{ min-width: 0; }
</style>
</head>
<body>

<canvas id="stars-canvas" aria-hidden="true"></canvas>

<main class="page">
  <section class="content">
    <div class="title-wrap">
      <h1 class="title">ЧЁРНАЯ СТРЕЛА</h1>
    </div>

    <div class="tracks" id="tracks">
      <article class="track" data-title="Трек 1" data-part="Глава 1" data-src="media/01.mp3">
        <div class="track-left">
          <div class="track-title" data-title>Джон мщу-за-всех</div>
          <div class="track-chapter">Пролог</div>
        </div>
        <time class="track-time">12:34</time>
      </article>

      <div class="divider"></div>

      <article class="track" data-title="Трек 2" data-part="Глава 2" data-src="media/02.mp3">
        <div class="track-left">
          <div class="track-title" data-title>Джон мщу-за-всех</div>
          <div class="track-chapter">Пролог</div>
        </div>
        <time class="track-time">12:34</time>

        <div class="aff-card" role="status" aria-live="polite">
          <div class="aff-text" id="affText">Я люблю тебя &lt;З</div>
        </div>
      </article>

      <div class="divider"></div>
    </div>

    </section>
</main>

<script>
(() => {
  const phrases = [
    'Я люблю тебя <З',
    'У тебя всё получится!',
    'Ты умничка <З',
    'Я горжусь тобой!',
    'Ты прекрасна',
    'Ты моё солнышко <З'
  ];
  const el = document.getElementById('affText');
  if(!el) return;
  let i = 0;

  const getDur = () => {
    const d = getComputedStyle(el).transitionDuration.split(',')[0].trim();
    if (d.endsWith('ms')) return parseFloat(d) || 600;
    if (d.endsWith('s')) return (parseFloat(d) || 0.6) * 1000;
    return 600;
  };
  const D = getDur();

  function cycle(){
    el.classList.remove('show');
    setTimeout(() => {
      i = (i+1) % phrases.length;
      el.textContent = phrases[i];
      requestAnimationFrame(() => el.classList.add('show'));
    }, D);
  }

  el.textContent = phrases[i];
  requestAnimationFrame(() => el.classList.add('show'));
  setInterval(cycle, 7000);
})();

(() => {
  const getCSS = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const ruler = document.createElement('span');
  Object.assign(ruler.style,{
    position:'absolute', visibility:'hidden', whiteSpace:'nowrap',
    fontSize: getCSS('--t-title-size'),
    fontWeight: getCSS('--t-title-weight'),
    fontFamily: getComputedStyle(document.body).fontFamily
  });
  document.body.appendChild(ruler);

  document.querySelectorAll('.track-title[data-title]').forEach(el=>{
    const maxW = parseFloat(getCSS('--track-title-maxw'));
    const txt = el.textContent.trim().replace(/\s+/g,' ');
        el.setAttribute('data-full', txt);
el.setAttribute('title', txt);

    ruler.textContent = txt;
    if (ruler.offsetWidth <= maxW) return;

    const words = txt.split(' ');
    let out = '';
    for(let k=0;k<words.length;k++){
      const next = (out ? out+' ' : '') + words[k];
      ruler.textContent = next + '…';
      if (ruler.offsetWidth <= maxW){ out = next; continue; }

      if (words[k].length >= 7){
        let cut = words[k];
        while (cut.length > 1){
          cut = cut.slice(0,-1);
          const cand = (out ? out+' ' : '') + cut + '…';
          ruler.textContent = cand;
          if (ruler.offsetWidth <= maxW){ out = (out? out+' ' : '') + cut; break; }
        }
      }
      break;
    }
    el.textContent = out + '…';
  });
})();

</script>
<script>
// Prevent selection starts except for editable controls
(function(){
  function isEditable(el){
    return !!(el && (el.closest('input, textarea, [contenteditable="true"]')));
  }
  document.addEventListener('selectstart', function(e){
    if (!isEditable(e.target)) {
      e.preventDefault();
    }
  }, {passive:false});
})();
</script>

<script>
(function markAffLocks(){
  function update(){
    document.querySelectorAll('.track').forEach(card=>{
      const locked = !!card.querySelector('.aff-card');
      card.classList.toggle('is-locked', locked);
      if (locked){
        card.setAttribute('aria-disabled','true');
        card.tabIndex = -1;
      } else {
        card.removeAttribute('aria-disabled');
        if (!card.hasAttribute('tabindex')) card.tabIndex = 0;
      }
    });
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', update); }
  else { update(); }
  window.__updateAffLocks = update;
})();
</script>

<!-- === AUDIO SHEET v3 (Shadow DOM, fast re-open, -15/+30 skip) === -->
<template id="audio-sheet-tpl">

        <style>
          /* === Base reset for component === */
:host {
  --tail-color: #6E6E6E;
  --tail-pct: 8; /* artificial tail length (% of bar) */

  --bar-color: #8F8F8F;
  --fill-color: #ffffff;
  all: initial; }
:host, .sheet { 
  font-family: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
}

/* === Design tokens (variables) === */
:host{                /* лимит хвоста буфера в % ширины (20–30 для короткого визуального хвоста; 100 = без лимита) */

  /* sizes / controls */
  --knob-size: 12px;
  --btn-play-w: clamp(61px, 7vw, 73px);
  --btn-play-h: clamp(61px, 7vw, 73px);
  --play-bump: 2px;

  /* layout */
  --sheet-max-w: 700px;
  --sheet-radius-top: 18px;
  --sheet-radius-current: var(--sheet-radius-top);
  --cover-shadow-x: 0px;
  --cover-shadow-y: 0px;
  --cover-shadow-blur: 20px;
  --cover-shadow-spread: 0px;
  --cover-shadow-color: rgba(0,0,0,.42);
}

/* === Hardening: selection/drag === */
:host, .sheet, .sheet * { 
  -webkit-user-select: none; 
  user-select: none; 
  -webkit-touch-callout: none; 
}
img { -webkit-user-drag: none; }

/* === Progress bar & knob === */
.bar{ 
  position: relative; 
  cursor: pointer; 
  touch-action: none; 
}
.knob{
  position: absolute; 
  top: 50%; left: 0%;
  width: var(--knob-size); 
  height: var(--knob-size);
  border-radius: 50%; 
  transform: translate(-50%, -50%);
  background: #fff; 
  box-shadow: none; 
  opacity: .95;
  pointer-events: none;
}

/* === Play button === */
.btn.play{ 
  width: var(--btn-play-w); 
  height: var(--btn-play-h); 
}
.btn.play img.bump{ transform: scale(1.03); }
.btn.play img{ 
  width: 100%; height: 100%; 
  display: block; 
  object-fit: contain; 
  transition: transform .12s ease; 
  will-change: transform; 
}

/* === Overlay === */
:host, * { box-sizing: border-box; }
.overlay { 
  position: fixed; inset: 0; 
  display: grid; align-content: end; justify-items: center;
  background-color: transparent; backdrop-filter: none; 
  pointer-events: none; z-index: 999999;
  transition: background-color 160ms linear; 
}
.overlay.open { 
  background-color: rgba(7,6,8,0.55); 
  backdrop-filter: blur(8px); 
  pointer-events: auto; 
}

          .sheet { width: 100vw; height: 100dvh; box-sizing: border-box;
                   background: #423749;
                   border-radius: 0 0 0 0;
                   box-shadow: 0 1px 60px rgba(0,0,0,.6), 0 1px 0 rgba(255,255,255,.04) inset; overflow:hidden;
                   padding: clamp(16px,3.2vw,36px) clamp(16px,3.2vw,40px) calc(clamp(16px,3.2vw,40px) + env(safe-area-inset-bottom));
                   display: flex; flex-direction: column; gap: clamp(12px,2.2vw,20px);
                   transform: translateY(100%);
                   transition: transform var(--open-dur, 250ms) cubic-bezier(.2,.9,.2,1);
                   touch-action: none; will-change: transform, border-radius; }

          .cover { height: clamp(290px, 32vw, 390px); display:grid; place-items:center; margin-top: clamp(24px,8vh,120px); }
          .img { width: clamp(282px, 32vw, 382px); height: clamp(282px, 32vw, 382px);
                 background:#C4C4C4 center/cover no-repeat;
                 border-radius: clamp(10px,1.4vw,16px); box-shadow: var(--cover-shadow-x) var(--cover-shadow-y) var(--cover-shadow-blur) var(--cover-shadow-spread) var(--cover-shadow-color); overflow:hidden; }

          .meta { text-align: center; }
          .title { overflow:hidden;  position:relative; font: 780 clamp(18px,2.4vw,28px)/1.12 system-ui, -apple-system, Segoe UI, Roboto, Arial;
                   color: #C4C4C4; height:1.25em; white-space:nowrap; overflow:hidden;
                   -webkit-mask-image:linear-gradient(to right, transparent 0%, #000 9%, #000 91%, transparent 100%);
                           mask-image:linear-gradient(to right, transparent 0%, #000 9%, #000 91%, transparent 100%); }
          .title .track { display:inline-flex; gap:24px; will-change: transform; }
          .title.marquee .track{ animation: marquee var(--dur, 14s) linear infinite !important; }
          @keyframes marquee { from { transform: translateX(0) } to { transform: translateX(calc(-1 * var(--dist, 0px))) } }
          .author { color:#B4B4B4; font: 700 clamp(14px,1.8vw,18px)/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial; }

          .progress-wrap{ width:min(100%, clamp(320px, 60vw, 475px)); margin: 0 auto; }
          .bar{ height:4.5px; background: var(--bar-color); border-radius:999px; position:relative; }
          
/* artificial "tail" segment (independent of real buffer) */
.tail{
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: 0%;
  background: var(--tail-color);
  border-radius: 2px;
  z-index: 0;                /* ниже fill */
  pointer-events: none;
  transition: left .22s linear, width .22s linear;
  will-change: left, width;
}
.fill{ height:100%; width:0%; background:var(--fill-color, #ffffff); border-radius:999px;  }
          
  
/* === ADAPTIVE GAP (landscape default) === */
.controls {
  display: flex;
  align-items: center;
  justify-content: center;
  
  position: relative;
  top: 0; transform: translateY(var(--controls-dy));
}

          .btn{ all: unset; width: clamp(39px,6vw,48px); height: clamp(39px,6vw,48px); border-radius: 999px; display:grid; place-items:center; cursor:pointer; }
          .btn.play{ width: clamp(61px,7vw,73px); height: clamp(61px,7vw,73px); }
          

          /* === AFF lock: when an overlay is over the track, block interactions === */
.track.is-locked{ cursor: not-allowed; }
.track.is-locked .track-left, .track.is-locked .track-time{ opacity:.95; }

/* === Disable text selection globally (with safe exceptions) === */
html, body, .page{
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;        /* iOS long-press menu */
}
/* Re-enable selection where it should be allowed */
input, textarea, [contenteditable="true"], .allow-select{
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  -webkit-touch-callout: default;
}
/* === ICON SIZE VARIABLES + SCOPED OVERRIDES (final) === */
:root {
  --size-prev: 30px;
  --size-back15: 35px;
  --size-play: 60px;
  --size-fwd30: 35px;
  --size-next: 30px;
}
.controls img{ display:block; margin:auto; max-width:none; max-height:none; }
#prev img   { width: var(--size-prev)   !important; height: var(--size-prev)   !important; }
#back15 img { width: var(--size-back15)!important; height: var(--size-back15)!important; }
#pp img     { width: var(--size-play)   !important; height: var(--size-play)   !important; }
#fwd30 img  { width: var(--size-fwd30)  !important; height: var(--size-fwd30)  !important; }
#next img   { width: var(--size-next)   !important; height: var(--size-next)   !important; }

/* Применяем единым местом */

/* === Controls gap (single variable, shadow DOM override) === */
:host{
  --controls-gap: clamp(16px, 3vw, 48px);
}
/* === Inner controls container layout (pure gap control) === */
#controls.controls{
  display: inline-flex;
  align-items: center;
  justify-content: center !important;   /* не раздвигаем пространство */
  gap: var(--controls-gap) !important;  /* управляем только gap */
  width: auto;                           /* ширина по содержимому */
  margin: 0 auto;                        /* центрируем ряд */
}

/* === Movable sections (axis-based) === */
:host{ /* cap buffer width in % of bar (set 20..30 for short-tail look) */

  --axis: 0px;
  --head-dy: 20px;
  --title-dy: 150px;
  --controls-dy: 83px;
  --chapter-dy: 185px;
  --progress-dy: 205px;
}

/* make .meta's children participate as siblings */
.meta{ display: contents; }

/* enforce order & individual vertical offsets */
.cover{ order:10; position:relative; top: calc(var(--axis) + var(--head-dy)); }
.title{ order:20; position:relative; top: calc(var(--axis) + var(--title-dy)); }
.controls{ order:30; position:relative; top: calc(var(--axis) + var(--controls-dy)); }
.author{ order:40; position:relative; top: calc(var(--axis) + var(--chapter-dy)); }
.progress-wrap{ order:50; position:relative; top: calc(var(--axis) + var(--progress-dy)); }

/* time inside player (shadow) */
.time{
  display:flex;
  justify-content:space-between;
  color: #BEBEBE;
  font-family: Montserrat;
  font-size: clamp(12px, 1.1vw, 16px);
  font-weight: 600;
  margin-top: 6px;
  width: 100%;
}

    /* buffered portion of audio (loaded) */
    /* layering: buffer behind fill behind knob */
    .fill{ z-index: 1; position:absolute; left:0; top:0; bottom:0; }
    .knob{ z-index: 2; }
    
</style>
        <div class="overlay" aria-hidden="true">
          <div class="sheet" role="dialog" aria-label="Аудиоплеер">
            <div class="cover"><div class="img" id="cover" aria-hidden="true"></div></div>
            <div class="meta">
              <div class="title" id="title"><span>Название</span></div>
              <div class="author" id="author">Автор</div>
            </div>
            <div class="progress-wrap">
              <div class="bar">
                <div class="tail" id="tail"></div>

                <div class="fill" id="fill"></div>
                <div class="knob" id="knob" aria-hidden="true"></div>
                            </div>
              <div class="time"><span id="cur">00:00</span><span id="dur">00:00</span></div>
            </div>
            <div class="controls" id="controls">

              <button class="btn" id="prev"><img src="icon/Prev.svg" alt="prev"></button>
              <button class="btn" id="back15" title="-15 сек"><img src="icon/-15sec.svg" alt="back15"></button>
              <button class="btn play" id="pp"><img src="icon/Play.svg" alt="pp"></button>
              <button class="btn" id="fwd30" title="+30 сек"><img src="icon/+30sec.svg" alt="fwd30"></button>
              <button class="btn" id="next"><img src="icon/Next.svg" alt="next"></button>
            
</div>
            <audio id="audio" preload="metadata"></audio>
          </div>
        </div>
      
</template>
<script>
(() => {
  const DEFAULT_COVER = "img/cover.jpg";

  // Simple state machine
  const State = { IDLE:0, OPENING:1, OPEN:2, CLOSING:3 };

  class AudioSheet extends HTMLElement {
    constructor(){
      super();
      this._state = State.IDLE;
      const root = this.attachShadow({mode:'open'});
      const tpl = document.getElementById('audio-sheet-tpl');
      if (tpl) root.appendChild(tpl.content.cloneNode(true));
// refs
      const $o = this.$o = root.querySelector('.overlay');
      const $s = this.$s = root.querySelector('.sheet');
      // prevent clicks inside sheet from bubbling to overlay
      this.$s.addEventListener('click', (e)=> e.stopPropagation());
      this.$title = root.querySelector('#title'); queueMicrotask(() => this._bindTitleObserver?.());
      this.$author = root.querySelector('#author');
      this.$cover = root.querySelector('#cover');
      this.$fill = root.querySelector('#fill');
      this.$tail = root.querySelector('#tail');
      this.$bar  = root.querySelector('.bar');
      this.$buffer = root.querySelector('#tail');
      this.$cur = root.querySelector('#cur');
      this.$dur = root.querySelector('#dur');
      this.$pp = root.querySelector('#pp');
      this.$glyph = root.querySelector('#glyph');
      this.$prev = root.querySelector('#prev');
      this.$next = root.querySelector('#next');
      this.$back15 = root.querySelector('#back15');
      this.$fwd30 = root.querySelector('#fwd30');
      this.$audio = root.querySelector('#audio');

      // a11y/diagnostics: politely announce state to assistive tech
      this.$status = document.createElement('div');
      this.$status.id = 'status';
      this.$status.setAttribute('role','status');
      this.$status.setAttribute('aria-live','polite');
      this.$status.style.position = 'absolute';
      this.$status.style.width = '1px';
      this.$status.style.height = '1px';
      this.$status.style.overflow = 'hidden';
      this.$status.style.clipPath = 'inset(50%)';
      root.appendChild(this.$status);

      // helper to announce text once
      this._notify = (msg)=>{ try { if (!msg) return; this.$status.textContent = String(msg); } catch(e){} };

      

      
      // Helper: parse CSS time like '570ms' or '0.57s' to ms
      const _parseMs = (v)=>{
        v = String(v||'').trim();
        if (!v) return 570;
        if (v.endsWith('ms')) return Math.max(1, parseFloat(v));
        if (v.endsWith('s'))  return Math.max(1, parseFloat(v) * 1000);
        const n = parseFloat(v); return isFinite(n) ? Math.max(1, n) : 570;
      };
      const _getOpenDurMs = ()=> _parseMs(getComputedStyle(this.$s).getPropertyValue('--open-dur'));
// === Radius config & helper ===
      this.R_OPEN =  0;
      if (!isFinite(this.R_OPEN)) this.R_OPEN = 18;
      this.R_CLOSED =  0;
      if (!isFinite(this.R_CLOSED)) this.R_CLOSED = 18;
      this.setRadiusByPct = (pct)=>{ /* no-op: rounding removed */ };
// state
      this.playlist = [];
      this.index = 0;
      this._playing = false;
      this._bufferIntroDone = false;
      this._bufferEverAnimated = false;

      // helpers
      const sec = (s)=>{ if(!isFinite(s)) return "00:00"; s=Math.max(0,Math.floor(s)); const m=Math.floor(s/60), ss=String(s%60).padStart(2,'0'); return `${String(m).padStart(2,'0')}:${ss}`; };
      const clamp = (v, a, b) => Math.min(b, Math.max(a, v));

      // audio events
      this.$audio.addEventListener('loadedmetadata', ()=> {
        this.$dur.textContent = sec(this.$audio.duration);
        this.renderProgress();
        this.renderTail?.();
      });

      let __raf = null;
      this.$audio.addEventListener('timeupdate', ()=>{
        if (__raf) cancelAnimationFrame(__raf);
        __raf = requestAnimationFrame(()=>{
          this.renderProgress();
          this.renderTail?.();
          __raf = null;
        });
      });

      // buffering & error states
      this.$audio.addEventListener('waiting', ()=>{ this._notify('Буферизация…'); });
      this.$audio.addEventListener('playing', ()=>{ this._notify('Воспроизведение'); this.renderTail?.(); });
      this.$audio.addEventListener('stalled', ()=>{ this._notify('Поток прерван, пытаюсь восстановить…'); });
      this.$audio.addEventListener('error', ()=>{ 
        const code = (this.$audio.error && this.$audio.error.code) || 0;
        this._notify('Ошибка аудио' + (code? (' (код ' + code + ')') : ''));
      });

      // play/pause/end glyphs
      this.$audio.addEventListener('play',  ()=>{ this._playing = true;  this.$glyph?.classList.remove('icon-play'); this.$glyph?.classList.add('icon-pause'); });
      this.$audio.addEventListener('pause', ()=>{ this._playing = false; this.$glyph?.classList.add('icon-play');    this.$glyph?.classList.remove('icon-pause'); });
      this.$audio.addEventListener('ended', ()=>{ this._playing = false; this.$glyph?.classList.add('icon-play');    this.$glyph?.classList.remove('icon-pause'); });
// controls
      this.$pp.addEventListener('click', ()=> {
        if (!this.$audio.src) return;
        if (this._playing) this.$audio.pause(); else this.$audio.play().catch(err=>{ this._notify('Браузер запретил автостарт. Нажмите “Play”.'); });
      });
      this.$prev.addEventListener('click', ()=> { if(this.$prev.hasAttribute('disabled')) return; if(this.index>0){ this.loadByIndex(this.index-1); } });
      this.$next.addEventListener('click', ()=> { if(this.$next.hasAttribute('disabled')) return; if(this.index+1<this.playlist.length){ this.loadByIndex(this.index+1); } });
      this.$back15.addEventListener('click', ()=> {
        if (!this.$audio.src || !isFinite(this.$audio.duration)) return;
        this.$audio.currentTime = clamp(this.$audio.currentTime - 15, 0, this.$audio.duration);
        this.renderProgress();
      });
      this.$fwd30.addEventListener('click', ()=> {
        if (!this.$audio.src || !isFinite(this.$audio.duration)) return;
        this.$audio.currentTime = clamp(this.$audio.currentTime + 30, 0, this.$audio.duration);
        this.renderProgress();
      });

      // Close handlers
      $o.addEventListener('click', (e)=> { if (this._openedAt && (performance.now() - this._openedAt) < 700) return; if (this._state !== State.OPEN) return; if (e.target === $o) this.close(); });
      window.addEventListener('keydown', (e)=> { if (e.key === 'Escape') this.close(); });

      // Drag-to-close
      let dragging=false, startY=0, curPct=0;
      const onDown = (e)=>{
      dragging=true; 
      startY=('touches'in e?e.touches[0].clientY:e.clientY);
      // show rounding at drag start
      $s.style.transition='border-radius 120ms linear, transform 260ms cubic-bezier(.2,.9,.2,1)';
      this.$s.style.setProperty('--sheet-radius-current', getComputedStyle(this).getPropertyValue('--sheet-open-radius') || '18px');
    };
      const onMove = (e)=>{
      if(!dragging) return;
      const y=('touches'in e?e.touches[0].clientY:e.clientY);
      const dy=y-startY, h=$s.getBoundingClientRect().height||1;
      const pct=Math.max(0, Math.min(1, dy/h)); curPct=pct;
      $s.style.transform = `translateY(${pct*100}%)`;
      // keep rounding constant during drag
    };
      const onUp = ()=>{
      if(!dragging) return; dragging=false;
      $s.style.transition='transform 260ms cubic-bezier(.2,.9,.2,1)';
      const willClose = (curPct > 0.06);
      if (willClose){
        // close via component logic (removes blur and resets vars)
        this._hideOverlay();
      } else {
        // snap back open and remove rounding fast
        $s.style.transform='translateY(0%)';
        this.$s.style.setProperty('--sheet-radius-current', '0px');
      }
    };
      $s.addEventListener('touchstart', onDown, {passive:true});
      window.addEventListener('touchmove', onMove, {passive:true});
      window.addEventListener('touchend', onUp);
      window.addEventListener('touchcancel', onUp);
      document.addEventListener('visibilitychange', ()=>{ if(document.hidden) onUp(); });

      // progress render
      this.renderProgress = ()=>{
        if (!isFinite(this.$audio.duration) || this.$audio.duration<=0){
          this.$fill.style.width = "0%";
          this.$cur.textContent = "00:00";
          return;
        }
        const pct = (this.$audio.currentTime / this.$audio.duration) * 100;
        this.$fill.style.width = pct + "%";
        this.$cur.textContent = sec(this.$audio.currentTime);
      };
      // Artificial tail: short segment ahead of the knob (independent of real buffer)
      this.renderTail = ()=>{
        try {
    const a = this.$audio;
    const d = a && a.duration;
    const tail = this.$tail;
    if (!a || !isFinite(d) || d <= 0 || !tail){
      if (tail){ tail.style.left='0%'; tail.style.width='0%'; }
      return;
    }
    const leftPct  = (a.currentTime / d) * 100;
    const cap      = parseFloat(getComputedStyle(this.$s).getPropertyValue('--tail-pct')) || 25;
    const widthPct = Math.min(100 - leftPct, cap);
    tail.style.left  = leftPct + '%';
    tail.style.width = widthPct + '%';
  } catch(e){}
      };
    

    


      // ensure initial CSS values
      this._resetSheetInstant();
    }

    _resetSheetInstant(){
      // reset transform without animating
      this.$s.style.transition = 'none';
      this.$s.style.transform = 'translateY(100%)';
      clearTimeout(this._closeGuard);
      this._closeGuard = setTimeout(()=>{
        if (this._state === State.CLOSING) {
          this.$o.classList.remove('open');
          this.$o.setAttribute('aria-hidden','true');
          this.$audio.pause();
          this._playing = false;
      this._bufferIntroDone = false;
      this._bufferEverAnimated = false;
          this._resetSheetInstant();
          this._state = State.IDLE;
        }
      }, 900);}

    _showOverlay(){
      if (this._state === State.OPEN || this._state === State.OPENING) return;
      this._state = State.OPENING;
      // show overlay immediately; start anim next frame
      this._openedAt = performance.now();
      this.$o.classList.add('open');
      this.$o.setAttribute('aria-hidden','false');
      // two RAFs to ensure styles apply before transition
      requestAnimationFrame(()=>{
        this.$s.style.transition = 'transform var(--open-dur, 570ms) cubic-bezier(.2,.9,.2,1)';
        this.$s.style.transform = 'translateY(0%)';
        clearTimeout(this._openGuard);
        this._openGuard = setTimeout(()=>{ if (this._state === State.OPENING) { this._state = State.OPEN; } }, 900);this._openedAt = performance.now();
        // reference: fully-open sheet has no rounding
        this.$s.style.setProperty('--sheet-radius-current', '0px');
        
        // (radius schedule removed to follow reference mechanics)this._openedAt = performance.now();
        // set state to OPEN when transition ends (guarded)
        const onEnd = () => { this._state = State.OPEN; clearTimeout(this._openGuard); this.$s.removeEventListener('transitionend', onEnd); };
        this.$s.addEventListener('transitionend', onEnd, {once:true});
      });
    }

    _hideOverlay(){
      // animate out first, then hide overlay and reset
      if (this._state !== State.OPEN && this._state !== State.OPENING) return;
      this._state = State.CLOSING;
      this.$s.style.transition = 'transform 320ms cubic-bezier(.2,.9,.2,1)';
      this.$s.style.transform = 'translateY(100%)';
      clearTimeout(this._closeGuard);
      this._closeGuard = setTimeout(()=>{
        if (this._state === State.CLOSING) {
          this.$o.classList.remove('open');
          this.$o.setAttribute('aria-hidden','true');
          this.$audio.pause();
          this._playing = false;
      this._bufferIntroDone = false;
      this._bufferEverAnimated = false;
          this._resetSheetInstant();
          this._state = State.IDLE;
        }
      }, 900);
      const onEnd = () => {
        this.$o.classList.remove('open');
        this.$o.setAttribute('aria-hidden','true');
        this.$audio.pause();
        this._playing = false;
      this._bufferIntroDone = false;
      this._bufferEverAnimated = false;
        this._resetSheetInstant();
        this._state = State.IDLE;
        clearTimeout(this._closeGuard);
        this.$s.removeEventListener('transitionend', onEnd);
      };
      this.$s.addEventListener('transitionend', onEnd, {once:true});
    }

    setPlaylist(list, startIndex=0){
      this.playlist = Array.isArray(list) ? list : [];
      this.index = Math.min(Math.max(0, startIndex|0), Math.max(this.playlist.length-1,0));
      this.updateNav(); // keep nav buttons in sync
    }

    load(track){
      const t = track || this.playlist[this.index] || {};
      const title = t.partTitle || t.title || 'Без названия';
      const author = t.partLabel || t.author || '';
      // title marquee
      this.$title.classList.remove('marquee');
      this.$title.innerHTML = '';
      const tr = document.createElement('div'); tr.className = 'track';
      const s1 = document.createElement('span'); s1.textContent = title;
      const s2 = document.createElement('span'); s2.textContent = title; s2.setAttribute('aria-hidden','true');
      tr.appendChild(s1); tr.appendChild(s2); this.$title.appendChild(tr);
      const ensure = () => {
        const boxW = this.$title.clientWidth || 0, textW = s1.scrollWidth || 0;
        if (textW > boxW + 2){
          const gap = 24;
          this.$title.style.setProperty('--dist', (textW + gap) + 'px');
          const duration = Math.max(8, (textW + gap) / 18);
          this.$title.style.setProperty('--dur', duration + 's');
          this.$title.classList.add('marquee');
        } else {
          this.$title.classList.remove('marquee');
          this.$title.textContent = title;
        }
      };
      // delay measurement: 2x RAF + microtask
      requestAnimationFrame(()=> requestAnimationFrame(()=> { setTimeout(ensure, 0); }));
      if (document.fonts && document.fonts.ready) { try { document.fonts.ready.then(()=> ensure()); } catch(_){} }
      setTimeout(ensure, 60);
this.$author.textContent = author || '';
      // только валидный URL идёт как cover, всё остальное — дефолт
const pickCover = (t)=>{
  const c = (t?.cover || '').trim();
  if (!c) return DEFAULT_COVER;        // пусто → дефолт
  if (!/[./]/.test(c)) return DEFAULT_COVER; // метки вида "01" игнорируем
  return c;
};

{
  const url = pickCover(t);
  const img = new Image();
  img.onload = () => { this.$cover.style.backgroundImage = `url("${url}")`; };
  img.onerror = () => {
    this.$cover.style.backgroundImage = `url("${DEFAULT_COVER}")`;
    this._notify('Не удалось загрузить обложку: ' + url);
    console.warn('[AudioSheet] Обложка не загрузилась:', url);
  };
  img.src = url;
}
      this.$audio.src = t.src || '';
      if (this.$tail){ this.$tail.style.left='0%'; this.$tail.style.width='0%'; }
      this._bufferIntroDone = false;
      if (this.$buffer){ this.$buffer.style.left='0%'; this.$buffer.style.width='0%'; }
      if (this.$buffer) this.$buffer.style.width = '0%';
if (!t.src) {
  this._notify('У трека не указан путь к аудиофайлу');
}

    this.updateNav();

    }

    open(track){
      // prepare data
      // Build playlist from page tracks if not set
      if (!Array.isArray(this.playlist) || this.playlist.length===0){
        try{
          const cards = Array.from(document.querySelectorAll('.track[data-src]:not(.is-locked)'));
          const list = cards.map(c=>({ partTitle: c.getAttribute('data-title') || c.querySelector('.track-title')?.textContent?.trim() || 'Без названия',
                                       partLabel: c.getAttribute('data-part')  || c.querySelector('.track-chapter')?.textContent?.trim() || '',
                                       src: c.getAttribute('data-src') || '', cover: c.getAttribute('DEFAULT_COVER') || '' }));
          this.setPlaylist(list, 0);
        }catch(_){}
      }
      if (track){
        // pick index by src if possible
        const idx = this.playlist.findIndex(t => (t.src && track.src && t.src===track.src));
        if (idx >= 0) this.index = idx;
        this.load(track);
      } else {
        this.load();
      }
      // fast reaction: ensure we reset then show overlay asap
      this._resetSheetInstant();
      this._showOverlay();
      this.updateNav();
    }

    close(){ this._hideOverlay(); }
  }

  

  
  AudioSheet.prototype.updateNav = function(){
    try{
      const n = this.playlist.length|0;
      const atStart = (this.index <= 0) || (n <= 1);
      const atEnd   = (this.index >= n-1) || (n <= 1);
      const apply = (btn, disabled)=>{
        if (!btn) return;
        if (disabled){
          btn.setAttribute('disabled','');
          btn.setAttribute('aria-disabled','true');
          btn.style.opacity = '.35';
          btn.style.filter = 'grayscale(1)';
          btn.style.pointerEvents = 'none';
          btn.style.cursor = 'default';
        } else {
          btn.removeAttribute('disabled');
          btn.setAttribute('aria-disabled','false');
          btn.style.opacity = '';
          btn.style.filter = '';
          btn.style.pointerEvents = '';
          btn.style.cursor = '';
        }
      };
      apply(this.$prev, atStart);
      apply(this.$next, atEnd);
    }catch(e){}
  };


  AudioSheet.prototype.loadByIndex = function(i){
    if (!Array.isArray(this.playlist) || this.playlist.length===0) return;
    const n = this.playlist.length;
    const clamped = Math.max(0, Math.min(i|0, n-1));
    this.index = clamped;
    this.load(this.playlist[this.index]);
    this.updateNav();
  };

  
  // Keep title marquee responsive to container width and font loads
  AudioSheet.prototype._bindTitleObserver = function(){
    try{
      if (this._titleRO) return;
      const RO = window.ResizeObserver; if (!RO) return; const ro = new RO(()=>{
        const t = this.playlist?.[this.index] || null;
        // Re-run load title only (avoid audio restart)
        if (!t) return;
        const title = t.partTitle || t.title || 'Без названия';
        this.$title.classList.remove('marquee');
        this.$title.innerHTML = '';
        const tr = document.createElement('div'); tr.className = 'track';
        const s1 = document.createElement('span'); s1.textContent = title;
        const s2 = document.createElement('span'); s2.textContent = title; s2.setAttribute('aria-hidden','true');
        tr.appendChild(s1); tr.appendChild(s2); this.$title.appendChild(tr);
        const gap = 24;
        const boxW = this.$title.clientWidth || 0, textW = s1.scrollWidth || 0;
        if (textW > boxW + 2){
          this.$title.style.setProperty('--dist', (textW + gap) + 'px');
          const duration = Math.max(8, (textW + gap) / 18);
          this.$title.style.setProperty('--dur', duration + 's');
          this.$title.classList.add('marquee');
        }
      else {
        this.$title.classList.remove('marquee');
        this.$title.textContent = title;
      }

      });
      ro.observe(this.$title);
      this._titleRO = ro;
    }catch(_){}
  };
customElements.define('x-audio-sheet', AudioSheet);

  // Mount single instance
  const sheetEl = document.createElement('x-audio-sheet');
  document.documentElement.appendChild(sheetEl);

  // Public API
  window.AudioSheet = {
    open: (track) => sheetEl.open(track),
    setPlaylist: (list, i) => sheetEl.setPlaylist(list, i),
  };
// flush queued opens if any
try{
  const q = window.__xa_queue || [];
  while (q.length) { window.AudioSheet.open(q.shift()); }
}catch(_){ }


  // ====== Binding: fast pointerdown on active cards ======
  function getMeta(node){
  const tt = node.querySelector('.track-title');
  const liveTxt = tt?.textContent?.trim();
  const fullTxt = tt?.getAttribute('data-full')?.trim();
  let title = liveTxt || node.getAttribute('data-title') || node.textContent?.trim() || 'Аудио';
  if (liveTxt && (liveTxt.includes('…') || /\.\.\.$/.test(liveTxt)) && fullTxt) title = fullTxt;
  
    const label = node.getAttribute('data-part') 
              || node.querySelector('.track-chapter')?.textContent?.trim()
              || '';
    const src = node.getAttribute('data-src') || '';
    const cover = node.getAttribute('DEFAULT_COVER') || '';
    return { partTitle: title, partLabel: label, src, cover };
  }

  const OPEN_SELECTOR = '.track, [data-open-player]';

  // Fast reaction: pointerdown; fallback: keydown/Enter Space; click for legacy
  // Keep legacy click but it usually fires after pointerdown; this is harmless
  })();
</script>
<script>
(function(){
  function openFromCard(card){
    const meta = {
      partTitle: (function(){
  const tt = card.querySelector('.track-title');
  const liveTxt = tt?.textContent?.trim();
  const fullTxt = tt?.getAttribute('data-full')?.trim();
  if (liveTxt && (liveTxt.includes('…') || /\.\.\.$/.test(liveTxt)) && fullTxt) return fullTxt;
  return liveTxt || card.getAttribute('data-title') || 'Без названия';
})(),
      partLabel: card.getAttribute('data-part')  || card.querySelector('.track-chapter')?.textContent?.trim() || '',
      src: card.getAttribute('data-src') || '',
      cover: card.getAttribute('DEFAULT_COVER') || ''
    };
    // открываем ВСЕГДА — даже если src пустой
if (window.AudioSheet?.open){
  window.AudioSheet.open(meta);
} else {
  (window.__xa_queue = window.__xa_queue || []).push(meta);
}
  }

  function bind(){
    document.querySelectorAll('[data-open-player], .track:not(.is-locked), .audio-track:not(.is-locked), .playlist-item:not(.is-locked), .js-open-player:not(.is-locked)')
      .forEach(card => {
      // avoid double-binding
      if (card.__xa_bound) return;
      card.__xa_bound = true;
      
      // Safe tap: short touch without movement -> open player
      (function attachSafeTap(node){
        const TAP_MAX_TIME = 350; // ms
        const TAP_MAX_MOVE = 10;  // px
        let startX=0, startY=0, startT=0, pointerId=null, moved=false;

        function onDown(e){
          if (pointerId !== null) return;
          pointerId = e.pointerId ?? 'mouse';
          startX = e.clientX; startY = e.clientY; startT = performance.now(); moved = false;
          if (e.pointerId != null && node.setPointerCapture) { try { node.setPointerCapture(e.pointerId); } catch(_){} }
        }
        function onMove(e){
          if (pointerId === null) return;
          const dx = Math.abs(e.clientX - startX);
          const dy = Math.abs(e.clientY - startY);
          if (dx > TAP_MAX_MOVE || dy > TAP_MAX_MOVE) moved = true;
        }
        function onUp(e){
          if (node.classList.contains('is-locked') || node.getAttribute('aria-disabled')==='true') { pointerId=null; return; }
          if (pointerId === null) return;
          const dt = performance.now() - startT;
          const isTap = !moved && dt <= TAP_MAX_TIME;
          pointerId = null;
          if (isTap) openFromCard(node);
        }
        function onCancel(){ pointerId = null; }

        node.addEventListener('pointerdown', onDown, {passive:true});
        node.addEventListener('pointermove', onMove,  {passive:true});
        node.addEventListener('pointerup',   onUp,    {passive:true});
        node.addEventListener('pointercancel', onCancel);
      })(card);
card.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); if(!card.classList.contains('is-locked') && card.getAttribute('aria-disabled')!=='true'){ openFromCard(card); } }
      });
      card.tabIndex = card.tabIndex || 0;
      card.setAttribute('role', 'button');
      card.setAttribute('aria-label', (card.getAttribute('data-title')||'Открыть аудиоплеер'));
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bind);
  } else {
    bind();
  }
})();
</script>

<script>
// Suppress double-click / double-tap selection (desktop & mobile)
(function(){
  function isEditable(el){
    return !!(el && el.closest('input, textarea, [contenteditable="true"], .allow-select'));
  }
  function isInteractive(el){
    return !!(el && el.closest('a, button, [role="button"], [role="link"], .allow-select'));
  }
  // Desktop: block double-click selection before it starts
  document.addEventListener('mousedown', function(e){
    if (e.detail > 1 && e.button === 0 && !isEditable(e.target) && !isInteractive(e.target)) {
      e.preventDefault();
    }
  }, true); // capture

  document.addEventListener('dblclick', function(e){
    if (!isEditable(e.target) && !isInteractive(e.target)) {
      e.preventDefault();
      var sel = window.getSelection && window.getSelection();
      if (sel && sel.removeAllRanges) sel.removeAllRanges();
    }
  }, {passive:false});

  // Mobile: clean up any accidental selection after tap
  function clearSelIfNeeded(target){
    if (!isEditable(target) && !isInteractive(target)) {
      var sel = window.getSelection && window.getSelection();
      if (sel && sel.rangeCount) sel.removeAllRanges();
    }
  }
  document.addEventListener('touchend', function(e){
    clearSelIfNeeded(e.target);
  }, {passive:true});

  // As a final guard, if selection somehow appears, clear it
  document.addEventListener('selectionchange', function(){
    var sel = window.getSelection && window.getSelection();
    if (sel && sel.rangeCount) {
      var anchor = sel.anchorNode && sel.anchorNode.parentElement;
      if (anchor && !isEditable(anchor) && !isInteractive(anchor)) {
        sel.removeAllRanges();
      }
    }
  });
})();
</script>

<script>
// === Player Enhancer: single central toggle (Play/Pause), synced knob, safe bump, drag/contextmenu block ===
(function(){
  const ready = () => {
    const sheetEl = document.querySelector('x-audio-sheet');
    if (!sheetEl) return;
    try {
      // refs
      sheetEl.$ppImg = sheetEl.$pp?.querySelector('img') || sheetEl.$ppImg;
      sheetEl.$knob  = sheetEl.shadowRoot?.getElementById('knob') || sheetEl.$knob;
      sheetEl._icons = { play: 'icon/Play.svg', pause: 'icon/Pause.svg' };

      // preload icons and ensure Pause.svg exists, otherwise fallback
      const _preload = (url)=> new Promise(res=>{ const im=new Image(); im.onload=()=>res(true); im.onerror=()=>res(false); im.src=url; });
      (async ()=>{
        const okPause = await _preload(sheetEl._icons.pause);
        if (!okPause){ console.warn('[AudioSheet] Pause icon not found:', sheetEl._icons.pause); sheetEl._icons.pause = sheetEl._icons.play; }
      })();

      // sync knob WITH renderProgress (moves together with fill)
      try{
        if (!sheetEl.__origRender){
          sheetEl.__origRender = sheetEl.renderProgress?.bind(sheetEl);
          sheetEl.renderProgress = function(){
            if (this.__origRender) this.__origRender();
            try{
              const a = this.$audio;
              const pct = (a && a.duration>0) ? (a.currentTime / a.duration)*100 : 0;
              if (this.$knob) this.$knob.style.left = pct + '%';
            }catch(e){}
          };
        }
      }catch(e){ console.warn('[Enhancer] render patch failed', e); }

      // toggle behavior on central Play button
      if (sheetEl.$pp){
        sheetEl.$pp.addEventListener('click', (e)=>{
          e.preventDefault();
          const a = sheetEl.$audio; if (!a || !a.src) return;
          // bump on every click
          try{
            const img = sheetEl.$ppImg;
            if (img){
              img.classList.remove('bump'); void img.offsetWidth; // reflow to restart animation
              img.classList.add('bump');
              setTimeout(()=> img.classList.remove('bump'), 140);
            }
          }catch(_){}
          if (a.paused) a.play().catch(()=>{}); else a.pause();
        }, {capture:true});
      }

      // swap icon + bump on state changes
      if (sheetEl.$audio){
        sheetEl.$audio.addEventListener('play',  ()=>{ try{ if(sheetEl.$ppImg && sheetEl._icons.pause){ if(sheetEl.$ppImg.src.indexOf(sheetEl._icons.pause)===-1) sheetEl.$ppImg.src = sheetEl._icons.pause; } sheetEl.$ppImg?.classList.add('bump'); setTimeout(()=> sheetEl.$ppImg?.classList.remove('bump'), 140);}catch(e){} });
        sheetEl.$audio.addEventListener('pause', ()=>{ try{ if(sheetEl.$ppImg && sheetEl._icons.play){ if(sheetEl.$ppImg.src.indexOf(sheetEl._icons.play)===-1) sheetEl.$ppImg.src = sheetEl._icons.play; } }catch(e){} });
        sheetEl.$audio.addEventListener('ended', ()=>{ try{ if(sheetEl.$ppImg && sheetEl._icons.play){ if(sheetEl.$ppImg.src.indexOf(sheetEl._icons.play)===-1) sheetEl.$ppImg.src = sheetEl._icons.play; } }catch(e){} });
      }

      
      // ===== Seek by clicking/dragging on progress bar =====
      try{
        const bar  = sheetEl.shadowRoot?.querySelector('.bar');
        const fill = sheetEl.$fill ?? sheetEl.shadowRoot?.getElementById('fill');
        const a    = sheetEl.$audio;
        if (bar && a){
          let dragging = false, raf = null;

          const clamp = (v,min,max)=> v<min?min: v>max?max: v;
          const pctFromX = (clientX)=>{
            const r = bar.getBoundingClientRect();
            return clamp((clientX - r.left) / r.width, 0, 1);
          };
          const applySeek = (pct)=>{
            if (!isFinite(a.duration) || a.duration<=0) return;
            a.currentTime = pct * a.duration;
            // immediate visual feedback
            try{
              const p = pct*100;
              if (fill) fill.style.width = p + '%';
              if (sheetEl.$knob) sheetEl.$knob.style.left = p + '%';
            }catch(e){}
          };

          const onDown = (e)=>{
            if (!isFinite(a.duration) || a.duration<=0) return;
            dragging = true;
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            applySeek(pctFromX(clientX));
            window.addEventListener('pointermove', onMove, {passive:false});
            window.addEventListener('pointerup', onUp, {passive:false, once:true});
            window.addEventListener('touchmove', onMove, {passive:false});
            window.addEventListener('touchend', onUp, {passive:false, once:true});
          };
          const onMove = (e)=>{
            if (!dragging) return;
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            if (raf) return;
            raf = requestAnimationFrame(()=>{ raf=null; applySeek(pctFromX(clientX)); });
          };
          const onUp = (e)=>{
            dragging = false;
            window.removeEventListener('pointermove', onMove, {passive:false});
            window.removeEventListener('touchmove', onMove, {passive:false});
          };

          bar.addEventListener('pointerdown', onDown, {passive:false});
          bar.addEventListener('touchstart', onDown, {passive:false});
          bar.addEventListener('click', (e)=>{
            e.preventDefault();
            const clientX = e.clientX ?? (e.touches && e.touches[0]?.clientX);
            if (clientX!=null) applySeek(pctFromX(clientX));
          });
        }
      }catch(e){ console.warn('[Enhancer] seek init failed', e); }

      // block drag/contextmenu inside shadow
      sheetEl.shadowRoot?.addEventListener('dragstart', e => e.preventDefault());
      sheetEl.shadowRoot?.addEventListener('contextmenu', e => e.preventDefault());
    } catch(e){ console.warn('[Enhancer] init error', e); }
  };
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ready);
  else ready();

  // global: block drag/contextmenu on icons/images
  document.addEventListener('dragstart', e => { if (e.target.closest('img, svg')) e.preventDefault(); }, true);
  document.addEventListener('contextmenu', e => { if (e.target.closest('img, svg, button')) e.preventDefault(); }, true);
})();</script>

<script>
(() => {
  function updateEllipsisTitles(){
    document.querySelectorAll('.track-title').forEach(el => {
      const clipped = el.scrollWidth > el.clientWidth + 1;
      if (clipped) el.setAttribute('title', el.textContent.trim());
      else el.removeAttribute('title');
    });
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', updateEllipsisTitles);
  else updateEllipsisTitles();
  let to; window.addEventListener('resize', ()=>{ clearTimeout(to); to = setTimeout(updateEllipsisTitles, 150); });
})();
</script>
</body>
</html>
