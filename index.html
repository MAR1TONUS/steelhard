<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover">

<title>я люблю тебя≺З</title>

<link rel="stylesheet" href="splash.css">
<<<<<<< HEAD
=======
<link rel="stylesheet" href="mini-player.css?v=2">
>>>>>>> 82632be (1.1)

<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">

<style>
/* === ТВОИ СТИЛИ — НЕ МЕНЯЛ === */
body{ font-family:"Montserrat", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
h1{ font-family:"Bebas Neue Pro", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
html, body { -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
img{ -webkit-user-drag:none; }
html, body { -webkit-tap-highlight-color: transparent; }
:where(a, button, [tabindex]) { outline: none; }
:where(a, button, [tabindex]):focus,
:where(a, button, [tabindex]):focus-visible { outline: none; box-shadow: none; }
@font-face { font-family: "Bebas Neue Pro"; src: url("./fonts/BebasNeuePro_Regular.woff2") format("woff2"); font-weight: 400; font-style: normal; font-display: swap; }
@font-face { font-family: "Bebas Neue Pro"; src: url("./fonts/BebasNeuePro_Bold.woff2") format("woff2"); font-weight: 700; font-style: normal; font-display: swap; }
@font-face { font-family: "Bebas Neue Pro"; src: url("./fonts/BebasNeuePro_Light.woff2") format("woff2"); font-weight: 300; font-style: normal; font-display: swap; }

:root{
  --page-bg: #000; --content-max-w: 500px; --side-pad: 12px;
  --title-block-w: 100%; --title-top: 85px; --title-bottom: 90px;
  --title-size: 100px; --title-width: 100px; --title-weight: 400; --title-color: #fff; --title-letter-spacing: .5px; --title-line-height: 0.86;
  --divider-thickness: 2px; --divider-color: #282828; --divider-top: 12px; --divider-bottom: 12px;
  --t-title-size: 13px; --t-title-weight: 650; --t-title-color: #DBDADA;
  --t-chapter-size: 12px; --t-chapter-weight: 650; --t-chapter-color: #828282;
  --t-time-size: 12px; --t-time-weight: 700; --t-time-color: #616161;
  --track-title-maxw: 295px;
  --aff-bg: rgba(43,43,43,.75); --aff-radius: 7px; --aff-border: 1px solid rgba(83, 83, 83, 0.2);
  --aff-text-size: 13px; --aff-text-weight: 750; --aff-text-color: #939393; --aff-pad-v: 14px; --aff-pad-h: 14px; --aff-blur: 4px;
  --player-bg: #000; --light-color: rgba(255,255,255,.55); --light-blur: 34px; --light-size: 64vw;
  --time-top-margin: 10px; --time-font-weight: 800; --time-font-size: 14px; --time-color: #e7e7e7;
  --lane-min: 300px; --lane-max: 540px; --page-pad: 10px;
}
html,body{height:100%;}
body{ margin:0; background:var(--page-bg); color:#fff; font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x:hidden; }
.page { --rail: clamp(var(--rail-min), calc(100vw - 2 * var(--rail-pad)), var(--rail-max)); }
.content { --lane: clamp(var(--lane-min), calc(100vw - 2 * var(--page-pad)), var(--lane-max)); padding-inline: var(--page-pad); box-sizing: border-box; }
.title-wrap{ width:var(--title-block-w); margin:var(--title-top) auto var(--title-bottom); text-align:center; }
.title{ margin: 0 auto 24px; font-family: "Bebas Neue Pro"; font-size: var(--title-size); font-weight: var(--title-weight); letter-spacing: var(--title-letter-spacing); line-height: var(--title-line-height); color: var(--title-color); text-transform: uppercase; text-align: center; max-width: 250px; width: min(100%, var(--rail)); }
.tracks{ width: min(100%, var(--rail)); margin-inline: auto; }
.divider{ width: var(--lane); height: var(--divider-thickness); background: var(--divider-color); margin: 14px auto; box-sizing: border-box; }
.track{ width: var(--lane); margin-inline: auto; display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 12px; padding: 0px 7px; box-sizing: border-box; position: relative; }
.track-left{ min-width:0; }
.track-title{ max-width:var(--track-title-maxw); font-size:var(--t-title-size); font-weight:var(--t-title-weight); color:var(--t-title-color); line-height:1.25; }
.track-chapter{ margin-top:2px; font-size:var(--t-chapter-size); font-weight:var(--t-chapter-weight); color:var(--t-chapter-color); }
.track-time{ margin-left:auto; flex:0 0 auto; font-size:var(--t-time-size); font-weight:var(--t-time-weight); color:var(--t-time-color); }
.aff-card{ position:absolute; left:50%; top:50%; transform: translate(-50%,-50%); width: var(--lane); box-sizing: border-box; min-height: calc(var(--aff-pad-v)*2 + var(--aff-text-size)*1.2); padding:var(--aff-pad-v) var(--aff-pad-h); background:var(--aff-bg); border:var(--aff-border); border-radius:var(--aff-radius); text-align:center; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:2; backdrop-filter:blur(var(--aff-blur)); }
.aff-text{ font-size:var(--aff-text-size); font-weight:var(--aff-text-weight); color:var(--aff-text-color); line-height:1.2; white-space:nowrap; opacity:0; transition: opacity .6s ease; }
.aff-text.show{ opacity:1; }
:root { --list-title-width: clamp(220px, 68vw, 540px); }
.tracks .track-title { width: var(--list-title-width); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; -webkit-mask-image: none !important; mask-image: none !important; }
.tracks .track-chapter { max-width: var(--list-title-width); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; -webkit-mask-image: none !important; mask-image: none !important;}
.tracks .track {
  padding-top: 9px;
  padding-bottom: 9px;
}
.tracks .track + .track {
  border-top: var(--divider-thickness) solid var(--divider-color);
}
html { scrollbar-width: none; }                 /* Firefox */
html::-webkit-scrollbar { width: 0; height: 0; }/* Chrome/Edge/Safari */
</style>
</head>

<body>

  <!-- ЗАГЛУШКА -->
<launch-splash
  launch-at="2025-09-01T00:00:00+03:00"
  soon-text="Совсем скоро здесь что-нибудь появится"
  welcome-text="Привет моё солнышко. Я очень долго к этому шёл и раз ты это читаешь, то я безумно рад, что у меня всё получилось!

Сейчас наступает не самый лёгкий для нас обоих период. У тебя будет очень мнго работы, а у меня учёба. Как бы всё не было, я знаю, что у нас всё получится. Мы справимся со всем, проживём эти моменты и всё будет хорошо. Ты у меня большая молодец и я горд за то, что именно ты моя девушка. Я счастлив, что мне повезло раздель минуты своей жизни именно с тобой. У тебя всё получится, ты главное не опускай свои лапки.

К сожалению я не смогу быть с тобой рядом, обнять или поцеловать. Понимая как тебе будет тяжело, я постарался всё же дать тебе частичку себя, чтобы ты смогла хотя бы меня слышать.

Один раз я заикнулся о том, что сделаю для тебя сборник сказочек и думаю, что настало время превратить свои слова в нечто особенное. Я подготовил для тебя аудио-книгу, которую ты сможешь слушать после тяжёлого денёчка, чтобы успокоиться или пере сном, чтобы было легче засыпать.

Книга поделена на главы и каждая глава будет появляться после 20:00, а заблокированные произведения закрываются оверлеем. Произведение выбирал такое, чтобы тебе понравилось.

Больше я задерживать тебя не буду, нажми на кнопочку ниже и сможешь послушать первую часть, а следующую придётся подождать. Я люблю тебя моя дорогая, очень сильно"
  btn-text="УГУМ"
  app-target="#app"
></launch-splash>


<!-- ОСНОВНАЯ СТРАНИЦА -->
<div id="app" hidden>
 <main class="page">
  <section class="content">
    <div class="title-wrap">
      <h1 class="title">ЧЁРНАЯ СТРЕЛА</h1>
    </div>

    <div class="tracks" id="tracks">
      <article class="track" data-src="media/00.mp3">
  <div class="track-left">
    <div class="track-title">Пролог</div>
    <div class="track-chapter">Джон Мщу-за-Всех</div>
  </div>
</article>

<article class="track" data-src="media/01.mp3">
  <div class="track-left">
    <div class="track-title">Глава 1</div>
    <div class="track-chapter">Под вывеской «Солнца» в Кэттли</div>
  </div>
</article>

<article class="track" data-src="media/02.mp3">
  <div class="track-left">
    <div class="track-title">Глава 2</div>
    <div class="track-chapter">На болоте</div>
  </div>
</article>

<article class="track" data-src="media/03.mp3">
  <div class="track-left">
    <div class="track-title">Глава 3</div>
    <div class="track-chapter">Тайна Зелёного леса</div>
  </div>
</article>

<article class="track" data-src="media/04.mp3">
  <div class="track-left">
    <div class="track-title">Глава 4</div>
    <div class="track-chapter">Кровожадная охота</div>
  </div>
</article>

<article class="track" data-src="media/05.mp3">
  <div class="track-left">
    <div class="track-title">Глава 5</div>
    <div class="track-chapter">Незнакомец в сумерках</div>
  </div>
</article>

<article class="track" data-src="media/06.mp3">
  <div class="track-left">
    <div class="track-title">Глава 6</div>
    <div class="track-chapter">Вопросы без ответов</div>
  </div>
</article>

<article class="track" data-src="media/07.mp3">
  <div class="track-left">
    <div class="track-title">Глава 7</div>
    <div class="track-chapter">Две клятвы</div>
  </div>
</article>

<article class="track" data-src="media/08.mp3">
  <div class="track-left">
    <div class="track-title">Глава 8</div>
    <div class="track-chapter">Комната над часовней и потайной ход</div>
  </div>
</article>

<article class="track" data-src="media/09.mp3">
  <div class="track-left">
    <div class="track-title">Глава 9</div>
    <div class="track-chapter">Тропа выбора</div>
  </div>
</article>

<article class="track" data-src="media/10.mp3">
  <div class="track-left">
    <div class="track-title">Глава 10</div>
    <div class="track-chapter">Дом на берегу</div>
  </div>
</article>

<article class="track" data-src="media/11.mp3">
  <div class="track-left">
    <div class="track-title">Глава 11</div>
    <div class="track-chapter">Бои во мраке и крест Святой Девы</div>
  </div>
</article>

<article class="track" data-src="media/12.mp3">
  <div class="track-left">
    <div class="track-title">Глава 12</div>
    <div class="track-chapter">На борту «Доброй Надежды»</div>
  </div>
</article>

<article class="track" data-src="media/13.mp3">
  <div class="track-left">
    <div class="track-title">Глава 13</div>
    <div class="track-chapter">Логовище</div>
  </div>
</article>

<article class="track" data-src="media/14.mp3">
  <div class="track-left">
    <div class="track-title">Глава 14</div>
    <div class="track-chapter">В доме врагов моих</div>
  </div>
</article>

<article class="track" data-src="media/15.mp3">
  <div class="track-left">
    <div class="track-title">Глава 15</div>
    <div class="track-chapter">Мёртвый шпион</div>
  </div>
</article>

<article class="track" data-src="media/16.mp3">
  <div class="track-left">
    <div class="track-title">Глава 16</div>
    <div class="track-chapter">В монастырской церкви и граф Райзингэм</div>
  </div>
</article>

<article class="track" data-src="media/17.mp3">
  <div class="track-left">
    <div class="track-title">Глава 17</div>
    <div class="track-chapter">Снова арбалестер</div>
  </div>
</article>

<article class="track" data-src="media/18.mp3">
  <div class="track-left">
    <div class="track-title">Глава 18</div>
    <div class="track-chapter">Зов трубы</div>
  </div>
</article>

<article class="track" data-src="media/19.mp3">
  <div class="track-left">
    <div class="track-title">Глава 19</div>
    <div class="track-chapter">Битва при Шорби</div>
  </div>
</article>

<article class="track" data-src="media/20.mp3">
  <div class="track-left">
    <div class="track-title">Глава 20</div>
    <div class="track-chapter">Битва при Шорби — исход</div>
  </div>
</article>

<article class="track" data-src="media/21.mp3">
  <div class="track-left">
    <div class="track-title">Глава 21</div>
    <div class="track-chapter">Разгром Шорби</div>
  </div>
</article>

<article class="track" data-src="media/22.mp3">
  <div class="track-left">
    <div class="track-title">Глава 22</div>
    <div class="track-chapter">Ночь в лесу Алисия Райзингэм</div>
  </div>
</article>

<article class="track" data-src="media/23.mp3">
  <div class="track-left">
    <div class="track-title">Глава 23</div>
    <div class="track-chapter">Тени ночи</div>
  </div>
</article>
    </div>
  </section>
 </main>
</div>

<!-- Плеер как у тебя -->
<template id="audio-sheet-tpl">
  <link rel="stylesheet" href="views/portrait.css">
  <link rel="stylesheet" href="views/landscape.css">
  <style>
    :root{ --sheet-open-dur: 800ms; --sheet-close-dur: 800ms; --sheet-ease: cubic-bezier(.2,.9,.2,1); }
    .sheet{ transform: translateY(100%); transition: transform var(--sheet-open-dur) var(--sheet-ease); will-change: transform; }
    .overlay.open .sheet{ transform: translateY(0%); }
  </style>
  <div class="overlay" aria-hidden="true">
    <div class="sheet" role="dialog" aria-label="Аудиоплеер">
      <div class="cover"><div class="img" id="cover" aria-hidden="true"></div></div>
      <div class="meta">
        <div class="title" id="title"><span>Название</span></div>
        <div class="author" id="author">Автор</div>
      </div>
      <div class="controls" id="controls">
        <button class="btn" id="prev" aria-label="Предыдущий трек"></button>
        <button class="btn" id="back15" title="-15 сек" aria-label="Назад 15 секунд"></button>
        <button class="btn play" id="pp" aria-label="Воспроизвести/Пауза"></button>
        <button class="btn" id="fwd30" title="+30 сек" aria-label="Вперёд 30 секунд"></button>
        <button class="btn" id="next" aria-label="Следующий трек"></button>
      </div>
      <div class="progress-wrap">
        <div class="bar" id="bar"><div class="bg" id="bg"></div><div class="fill" id="fill"></div><div class="knob" id="knob" aria-hidden="true"></div></div>
        <div class="time"><span id="cur">00:00</span><span id="dur">00:00</span></div>
      </div>
      <audio id="audio" preload="metadata"></audio>
    </div>
  </div>
</template>

<script src="player-core.bundle.v3.3.js"></script>
<script src="splash.js" defer></script>
<script src="mini-player.js?v=2" defer></script>

<script>
/**
 * Глобальный цикл фраз:
 *  — НЕ зависит от появления карточек (не сбрасывается)
 *  — при появлении нового affText — ставит текущую фразу и продолжает цикл
 *  — выбор следующей фразы рандомный, с исключением последних двух
 *  — обновляет ВСЕ видимые .aff-text одновременно
 */
(() => {
  const phrases = [
    'Я люблю тебя <З','У тебя всё получится!','Ты умничка <З',
    'Я горжусь тобой!','Ты прекрасна','Ты моё солнышко <З','У тебя волшебные глазки','Улыбайся моя дорогая)'
  ];

  let currentIndex = 0;
  const history = []; // последние 2 индекса

  function pickNext() {
    const blocked = new Set(history);
    blocked.add(currentIndex);
    const choices = [];
    for (let i=0;i<phrases.length;i++){
      if (!blocked.has(i)) choices.push(i);
    }
    // если вариантов мало (фраз < 3), просто рандом, но не одинаковая подряд
    let idx;
    if (choices.length === 0) {
      do { idx = Math.floor(Math.random() * phrases.length); } while (idx === currentIndex && phrases.length > 1);
    } else {
      idx = choices[Math.floor(Math.random() * choices.length)];
    }
    history.push(currentIndex);
    while (history.length > 2) history.shift();
    currentIndex = idx;
  }

  function setAll(text, withFX=true) {
    const nodes = document.querySelectorAll('.aff-text, #affText');
    nodes.forEach(node => {
      // не сбрасываем чужие классы, только обновляем текст и «show»
      const D = (() => {
        const d = (getComputedStyle(node).transitionDuration || '0s').split(',')[0].trim();
        if (d.endsWith('ms')) return parseFloat(d) || 600;
        if (d.endsWith('s'))  return (parseFloat(d) || 0.6) * 1000;
        return 600;
      })();

      if (withFX) node.classList.remove('show');
      setTimeout(() => {
        node.textContent = text;
        if (withFX) requestAnimationFrame(() => node.classList.add('show'));
      }, withFX ? D : 0);
    });
  }

  // Запускаем глобальный цикл
  function tick() {
    pickNext();
    setAll(phrases[currentIndex], true);
  }

  // Инициализация: выставим первую фразу без эффекта (чтобы не мигнуло)
  setAll(phrases[currentIndex], false);
  const T = 7000; // период смены фраз
  setInterval(tick, T);

  // Когда появляется новый affText (из цепочки) — ставим на него текущую фразу, не сбрасывая цикл
  document.addEventListener('aff:mounted', (ev) => {
    const node = ev.detail && ev.detail.el ? ev.detail.el : null;
    if (!node) return;
    node.textContent = phrases[currentIndex];
    // дать «show», если у тебя на нём анимация входа
    requestAnimationFrame(() => node.classList.add('show'));
  });

})();
</script>


<script>
/* усечение заголовков — как было */
(() => {
  const getCSS = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const ruler = document.createElement('span');
  Object.assign(ruler.style,{ position:'absolute', visibility:'hidden', whiteSpace:'nowrap', fontSize:getCSS('--t-title-size'), fontWeight:getCSS('--t-title-weight'), fontFamily:getComputedStyle(document.body).fontFamily });
  document.body.appendChild(ruler);
  document.querySelectorAll('.track-title[data-title]').forEach(el=>{
    const maxW = parseFloat(getCSS('--track-title-maxw'));
    const txt = el.textContent.trim().replace(/\s+/g,' '); el.setAttribute('title', txt);
    ruler.textContent = txt; if (ruler.offsetWidth <= maxW) return;
    const words = txt.split(' '); let out = '';
    for(let k=0;k<words.length;k++){
      const next = (out ? out+' ' : '') + words[k]; ruler.textContent = next + '…';
      if (ruler.offsetWidth <= maxW){ out = next; continue; }
      if (words[k].length >= 7){ let cut = words[k]; while (cut.length > 1){ cut = cut.slice(0,-1); const cand = (out ? out+' ' : '') + cut + '…'; ruler.textContent = cand; if (ruler.offsetWidth <= maxW){ out = (out? out+' ' : '') + cut; break; } } }
      break;
    }
    el.textContent = out + '…';
  });
})();
</script>

<script>
/* запрет выделения — как было */
(function(){
  const isEditable = (el) => { if (!el) return false; if (el.closest('[contenteditable="true"]')) return true; const tag = el.tagName; return tag==='INPUT'||tag==='TEXTAREA'; };
  document.addEventListener('selectstart', (e) => { if (!isEditable(e.target)) e.preventDefault(); });
  document.addEventListener('mousedown', (e) => { if (e.detail>1 && !isEditable(e.target)) e.preventDefault(); }, { passive:false });
  document.addEventListener('dblclick', (e) => { if (!isEditable(e.target)) e.preventDefault(); }, { passive:false });
  document.addEventListener('selectionchange', () => { const sel = window.getSelection && window.getSelection(); if (!sel || sel.isCollapsed) return; const anchorEl = sel.anchorNode && (sel.anchorNode.nodeType===1 ? sel.anchorNode : sel.anchorNode.parentElement); if (!isEditable(anchorEl)) { try { sel.removeAllRanges(); } catch(_) {} } });
})();
</script>

<script>
/* Открыть плеер по клику (делегированно) */
(function () {
  const list = document.getElementById('tracks'); if (!list) return;

  // утилиты
  const textOf = (root, sel) => {
    const n = root.querySelector(sel);
    return n ? n.textContent.trim() : '';
  };
  const attr = (root, name) =>
    root.getAttribute(name) || root.dataset[name] || '';

  // строим meta так, чтобы в шторке было «сначала название, ниже — глава»
  function buildMetaFromCard(card) {
    const title     = textOf(card, '.track-chapter'); // НАЗВАНИЕ ГЛАВЫ (крупно)
    const partTitle = textOf(card, '.track-title');   // «Глава N» (ниже)
    const src       = attr(card, 'src');              // data-src с путём к аудио
    const cover     = attr(card, 'cover');            // если планируешь обложки
    return { title, partTitle, src, cover, opener: card };
  }

  list.addEventListener('click', (e) => {
    const card = e.target.closest('.track');
    if (!card) return;

    // если на карточке ещё лежит твой оверлей — не даём открыться
    if (card.querySelector('.aff-card, .aff, [data-role="aff"]')) {
      e.preventDefault(); e.stopPropagation();
      return;
    }

    const meta = buildMetaFromCard(card);
    if (!meta.src) {  // на всякий случай
      console.warn('[player] empty src on card', card);
      return;
    }
    if (window.AudioSheet && window.AudioSheet.open) {
      window.AudioSheet.open(meta);   // ← ОТКРЫВАЕМ ПЛЕЕР
    } else {
      console.error('AudioSheet is not loaded');
    }
  });
})();
</script>

<script>
/**
 * Расписание треков:
 *  • Пролог (первый .track) — открыт всегда после входа.
 *  • Первая разблокировка глав: 02.09.2025 20:00 (далее — каждый день в 20:00).
 *  • При заходе в любой день «догоняем» состояние по дате: сразу открыты все,
 *    которые ДОЛЖНЫ были открыться, а следующая — под твоим AFF.
 *  • Твой AFF/стили не трогаем: создаём ту же разметку и шлём 'aff:mounted'.
 */

(function () {
  const list = document.getElementById('tracks');
  if (!list) return;

  const VEIL_MS = 500;
  const AFF_FALLBACK_MS = 400;

  const SITE_OPEN_AT     = new Date(2025, 8, 1, 0, 0, 0, 0);  // 01.09.2025 00:00
  const FIRST_UNLOCK_AT  = new Date(2025, 8, 2, 20, 0, 0, 0); // 02.09.2025 20:00
  const DAY_MS = 86400000;

  const qAff = (root) => root.querySelector('.aff-card, .aff, [data-role="aff"]');
  const forceReflow = (el) => { void (el && el.offsetWidth); };

  function addAff(card){
    if (qAff(card)) return;
    // РОВНО твоя структура (без подмены текста — текст крутит твой цикл)
    const aff = document.createElement('div');
    aff.className = 'aff-card';
    aff.setAttribute('data-role','aff');
    aff.innerHTML = `<div class="aff-inner"><span class="aff-text" id="affText"></span></div>`;
    card.appendChild(aff);

    card.classList.add('is-locked');
    card.setAttribute('aria-disabled','true');
    card.style.pointerEvents = 'none';

    const span = aff.querySelector('.aff-text') || aff.querySelector('#affText');
    document.dispatchEvent(new CustomEvent('aff:mounted', { detail: { el: span }}));
  }

  function hideAff(card){
    return new Promise((resolve) => {
      const aff = qAff(card);
      const finish = () => {
        if (aff && aff.parentNode) aff.parentNode.removeChild(aff);
        card.classList.remove('is-locked');
        card.removeAttribute('aria-disabled');
        card.style.pointerEvents = 'auto';
        card.querySelectorAll('.reveal-veil').forEach(v => v.remove());
        resolve();
      };
      if (!aff) return finish();

      const durStr = (getComputedStyle(aff).transitionDuration || '0s').split(',')[0].trim();
      let dur = 0;
      if (durStr.endsWith('ms')) dur = parseFloat(durStr) || 0;
      else if (durStr.endsWith('s')) dur = (parseFloat(durStr) || 0) * 1000;

      if (dur > 0){
        let done = false;
        const onEnd = (e) => {
          if (e.target !== aff || done) return;
          done = true; aff.removeEventListener('transitionend', onEnd);
          finish();
        };
        aff.addEventListener('transitionend', onEnd);
        aff.classList.add('aff-hide');
        aff.style.opacity = '0';
        setTimeout(() => { if (!done){ aff.removeEventListener('transitionend', onEnd); finish(); } }, dur + 80);
      } else {
        aff.style.willChange = 'opacity';
        aff.style.transition = `opacity ${AFF_FALLBACK_MS}ms ease`;
        aff.style.opacity = getComputedStyle(aff).opacity || '1';
        forceReflow(aff);
        aff.style.opacity = '0';
        setTimeout(finish, AFF_FALLBACK_MS + 40);
      }
    });
  }

  function appendWithMask(next){
    if (getComputedStyle(next).position === 'static') next.style.position = 'relative';
    addAff(next);                 // кладём aff ДО вставки (без просвета)
    list.appendChild(next);

    const veil = document.createElement('div');
    veil.className = 'reveal-veil';
    veil.style.opacity = '1';
    veil.style.transition = `opacity ${VEIL_MS}ms ease`;
    next.appendChild(veil);
    forceReflow(veil);
    veil.style.opacity = '0';
    setTimeout(() => veil.remove(), VEIL_MS + 40);
  }

  // Сколько глав (кроме Пролога) уже должны быть открыты к текущему моменту?
  function unlockedCountByNow(now = new Date()){
    if (now < FIRST_UNLOCK_AT) return 0;
    const diff = now - FIRST_UNLOCK_AT;                 // ms с момента 1-й разблокировки
    return Math.floor(diff / DAY_MS) + 1;               // +1 — за первый день (02.09 20:00)
  }

  let queue = [];
  let currentLockedIndex = 1; // 0 — Пролог, 1 — текущая «под aff»

  function initByDate(){
    const all = Array.from(list.querySelectorAll('.track'));
    if (!all.length) return;

    const prologue = all[0];
    const rest     = all.slice(1);

    // Пролог открыт
    prologue.classList.remove('is-locked');
    prologue.removeAttribute('aria-disabled');
    prologue.style.pointerEvents = 'auto';

    // Сколько уже «должно быть» открыто
    const openN = unlockedCountByNow();

    const opened = rest.slice(0, openN);
    const locked = rest[openN] ? [rest[openN]] : [];
    queue = rest.slice(openN + (locked.length ? 1 : 0));

    // Оставим в DOM только prologue + opened + locked
    const keep = [prologue, ...opened, ...locked];
    Array.from(list.querySelectorAll(':scope > .track')).forEach(t => {
      if (!keep.includes(t)) t.remove();
    });
    keep.forEach(t => { if (t.parentNode !== list) list.appendChild(t); });

    // Снять aff у «opened», если вдруг был
    opened.forEach(t => {
      const aff = qAff(t);
      if (aff) aff.remove();
      t.classList.remove('is-locked');
      t.removeAttribute('aria-disabled');
      t.style.pointerEvents = 'auto';
    });

    if (locked[0]) addAff(locked[0]);

    // Индекс текущей «залоченной»
    currentLockedIndex = locked.length ? keep.indexOf(locked[0]) : -1;

    planNextUnlock();
  }

  function next20oclock(now = new Date()){
    const d = new Date(now);
    d.setHours(20, 0, 0, 0);
    if (d <= now) d.setDate(d.getDate() + 1);
    return d;
  }

  function planNextUnlock(){
    const now = new Date();
    const next = next20oclock(now);
    const ms = next - now;
    if (planNextUnlock._t) clearTimeout(planNextUnlock._t);
    planNextUnlock._t = setTimeout(() => {
      stepOnce().then(() => planNextUnlock());
    }, ms);
  }

  function stepOnce(){
    const tracksNow = Array.from(list.querySelectorAll(':scope > .track'));
    if (currentLockedIndex < 0 || !tracksNow[currentLockedIndex]) return Promise.resolve();

    const cur = tracksNow[currentLockedIndex];
    return hideAff(cur).then(() => {
      const next = queue.shift();
      if (next) {
        appendWithMask(next);
        const tracksAfter = Array.from(list.querySelectorAll(':scope > .track'));
        currentLockedIndex = tracksAfter.length - 1; // новая «под aff»
      } else {
        currentLockedIndex = -1; // всё открыто
      }
    });
  }

  // Старт: ждём, когда заглушка откроет #app (снимет hidden)
  const app = document.getElementById('app');
  if (!app) return;

  if (!app.hasAttribute('hidden')) {
    initByDate();
  } else {
    const mo = new MutationObserver(muts => {
      for (const m of muts) {
        if (m.type === 'attributes' && m.attributeName === 'hidden' && !app.hasAttribute('hidden')) {
          mo.disconnect();
          initByDate();
          break;
        }
      }
    });
    mo.observe(app, { attributes: true });
  }
})();
</script>

<script> AudioSheet.configure({ cover: 'img/cover.jpg' }); </script>

</body>
</html>
